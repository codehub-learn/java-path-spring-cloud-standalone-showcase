server:
  port: 8080

spring:
  application:
    name: restaurant-system-api-gateway
  cache:
    type: caffeine
  main:
    banner-mode: off
  cloud:
    loadbalancer:
      cache:
        enabled: true
        caffeine:
          spec: maximumSize=1000,expireAfterWrite=15s,expireAfterAccess=5s
    gateway:
      server:
        webflux:
          discovery:
            locator:
              enabled: true
              lower-case-service-id: true
          default-filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 500
                redis-rate-limiter.burstCapacity: 1000
                key-resolver: "#{@globalKeyResolver}"

          # Static routes (no discovery locator magic yet)
          routes:
            - id: restaurant-monolith
              uri: lb://RESTAURANT-SYSTEM-SERVICES-MONOLITH
              predicates:
                # Whatever paths your monolith exposes.
                # If controllers are on /api/**, just proxy them as-is:
                - Path=/api/reservations/**,/api/customers/**
                - Method=GET,POST,PUT,DELETE
              filters:
                # Rate limit = X requests / second / key
                # it expects a KeyResolver bean. If none is present → rate limiting may silently not work or default to per-route
                # behavior depending on the version.
                #
                # Effect:
                # - Max 200 req/sec TOTAL
                # - Max 20 req/sec per user
                # This prevents:
                # - DDoS
                # - Single noisy clients
                # - Backend saturation
                - name: RequestRateLimiter
                  args:
                    redis-rate-limiter.replenishRate: 200
                    redis-rate-limiter.burstCapacity: 400
                    key-resolver: "#{@globalKeyResolver}"
                - name: RequestRateLimiter
                  args:
                    redis-rate-limiter.replenishRate: 10 # Each API token: max 10 req/sec
                    redis-rate-limiter.burstCapacity: 20 # Burst allowed up to 20
                    key-resolver: "#{@apiKeyResolver}"
            - id: notification-monolith
              uri: lb://NOTIFICATION-SERVICE
              predicates:
                # Whatever paths your monolith exposes.
                # If controllers are on /api/**, just proxy them as-is:
                - Path=/api/notifications/**
                - Method=GET,POST,PUT,DELETE
              filters:
                - name: RequestRateLimiter
                  args:
                    redis-rate-limiter.replenishRate: 15
                    redis-rate-limiter.burstCapacity: 30
                    key-resolver: "#{@apiKeyResolver}"
          globalcors:
            cors-configurations:
              '[/**]':
                allowed-origins:
                  - http://localhost:4200
                  - http://localhost:3000
                allowed-methods:
                  - GET
                  - POST
                  - PUT
                  - DELETE
                allowed-headers: "*"
                allow-credentials: true
management:
  endpoints:
    web:
      exposure:
        include: gateway,health,info,metrics
  endpoint:
    health:
      show-details: always

eureka:
  client:
    register-with-eureka: true
    fetch-registry: true
    # How often to pull the registry from Eureka
    registry-fetch-interval-seconds: 30
    refresh:
      enable: false
    service-url:
      defaultZone: http://localhost:8761/eureka/
  instance:
    prefer-ip-address: false
    hostname: localhost
    # Expiration > 2 × Renewal
    # How often this instance sends a heartbeat to Eureka
    lease-renewal-interval-in-seconds: 30
    # How long Eureka waits without heartbeats before evicting
    lease-expiration-duration-in-seconds: 90
    # Optional but nice: more unique instance IDs in dashboards/logs
    instance-id: ${spring.application.name}:${server.port}:${random.uuid}
    metadata-map:
      version: v0.0.1
      environment: dev